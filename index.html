<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TMA/WGMMA Async Pipeline with mbarrier</title>
  <style>
    body {
      font-family: system-ui, -apple-system, sans-serif;
      background: #0a0a0a;
      color: #e0e0e0;
      padding: 20px;
    }

    .container {
      max-width: 1100px;
      margin: 0 auto;
    }

    h1 {
      color: #76c7ff;
      font-size: 22px;
      margin-bottom: 30px;
      text-align: center;
    }

    .pipeline {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 30px;
      margin: 40px 0;
    }

    .actor {
      background: #1a1a2e;
      border-radius: 8px;
      padding: 20px;
      width: 180px;
      text-align: center;
    }

    .producer {
      border: 2px solid #ffd166;
    }

    .consumer {
      border: 2px solid #06d6a0;
    }

    .producer h2 {
      color: #ffd166;
      margin: 0 0 10px 0;
      font-size: 16px;
    }

    .consumer h2 {
      color: #06d6a0;
      margin: 0 0 10px 0;
      font-size: 16px;
    }

    .status {
      font-size: 14px;
      min-height: 40px;
      line-height: 1.4;
    }

    .buffer-container {
      display: flex;
      gap: 25px;
      justify-content: center;
      flex: 1;
    }

    .buffer {
      background: #16213e;
      border: 2px solid #4a5568;
      border-radius: 8px;
      padding: 15px;
      width: 170px;
      transition: all 0.3s ease;
    }

    .buffer h3 {
      margin: 0 0 15px 0;
      color: #ffd166;
      font-size: 14px;
      text-align: center;
    }

    .barrier {
      font-size: 12px;
      padding: 10px;
      margin: 10px 0;
      border-radius: 4px;
      text-align: center;
      transition: all 0.3s ease;
    }

    .barrier.idle {
      background: #2d3748;
      color: #a0aec0;
    }

    .barrier.waiting {
      background: #ef476f;
      color: #fff;
      font-weight: 600;
      animation: blink 1s infinite;
    }

    .barrier.signaled {
      background: #06d6a0;
      color: #000;
      font-weight: 600;
    }

    @keyframes blink {

      0%,
      100% {
        opacity: 1;
      }

      50% {
        opacity: 0.7;
      }
    }

    .buffer.loading {
      border-color: #ffd166;
      box-shadow: 0 0 15px rgba(255, 209, 102, 0.3);
    }

    .buffer.computing {
      border-color: #06d6a0;
      box-shadow: 0 0 15px rgba(6, 214, 160, 0.3);
    }

    .buffer.ready {
      border-color: #76c7ff;
      background: rgba(118, 199, 255, 0.1);
    }

    .controls {
      text-align: center;
      margin: 30px 0;
    }

    button {
      background: #9f7aea;
      color: #fff;
      border: none;
      padding: 12px 30px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
    }

    button:hover {
      background: #8b5cf6;
    }

    .step-info {
      margin-top: 20px;
      padding: 20px;
      background: #1a1a2e;
      border-radius: 8px;
      font-size: 14px;
      line-height: 1.5;
    }

    .step-info strong {
      color: #76c7ff;
    }

    .step-info ul {
      margin: 10px 0;
      padding-left: 20px;
    }

    .step-info li {
      margin: 5px 0;
    }

    .step-info code {
      background: #2d3748;
      padding: 2px 6px;
      border-radius: 3px;
      font-family: 'SF Mono', Monaco, monospace;
      font-size: 12px;
      color: #ffd166;
    }

    .phase-label {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 600;
      margin-bottom: 10px;
    }

    .phase-prologue {
      background: #9f7aea;
      color: #fff;
    }

    .phase-mainloop {
      background: #06d6a0;
      color: #000;
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>TMA/WGMMA Async Pipeline with mbarrier (QSIZE=2)</h1>
    <p style="text-align: center; color: #a0aec0; margin-bottom: 25px; font-size: 13px;">
      Key insight: Producer issues <code style="color: #ffd166;">cp.async.bulk</code> to ALL buffers back-to-back during prefetch (no waiting).<br>
      Synchronization via <code style="color: #06d6a0;">mbarrier</code> with <code>::complete_tx</code> — TMA hardware auto-signals on completion.
    </p>

    <div class="controls">
      <button onclick="nextStep()">Next Step →</button>
      <span style="margin-left: 20px; color: #76c7ff;">Step: <span id="stepNum">0</span>/7</span>
    </div>

    <div class="pipeline">
      <div class="actor producer">
        <h2>Producer (TMA)</h2>
        <div class="status" id="prodStatus">Idle</div>
      </div>

      <div class="arrow">→</div>

      <div class="buffer-container">
        <div class="buffer" id="buf0">
          <h3>Buffer 0</h3>
          <div class="barrier idle" id="load0">Load: Idle</div>
          <div class="barrier idle" id="store0">Store: Idle</div>
        </div>
        <div class="buffer" id="buf1">
          <h3>Buffer 1</h3>
          <div class="barrier idle" id="load1">Load: Idle</div>
          <div class="barrier idle" id="store1">Store: Idle</div>
        </div>
      </div>

      <div class="arrow">→</div>

      <div class="actor consumer">
        <h2>Consumer (WGMMA)</h2>
        <div class="status" id="consStatus">Idle</div>
      </div>
    </div>

    <div class="step-info" id="stepInfo"></div>
  </div>

  <script>
    const steps = [
      {
        step: 0, prod: "Idle", cons: "Idle", phase: "prologue",
        info: "<span class='phase-label phase-prologue'>PROLOGUE</span><br><strong>Initial State:</strong> Both buffers empty. Producer ready to begin prefetch phase. Consumer blocked, waiting for data.",
        buf0: {class: "", load: "Idle", store: "Idle"},
        buf1: {class: "", load: "Idle", store: "Idle"}
      },
      {
        step: 1, prod: "cp.async.bulk → Buf0", cons: "Blocked (Prologue)", phase: "prologue",
        info: "<span class='phase-label phase-prologue'>PROLOGUE</span><br><strong>Prefetch 1/2:</strong> Producer issues <code>cp.async.bulk</code> to Buffer 0. This is <em>non-blocking</em> — producer immediately continues without waiting for TMA completion.",
        buf0: {class: "loading", load: "Waiting", store: "Idle"},
        buf1: {class: "", load: "Idle", store: "Idle"}
      },
      {
        step: 2, prod: "cp.async.bulk → Buf1", cons: "Blocked (Prologue)", phase: "prologue",
        info: "<span class='phase-label phase-prologue'>PROLOGUE</span><br><strong>Prefetch 2/2:</strong> Producer immediately issues <code>cp.async.bulk</code> to Buffer 1 — <em>back-to-back, no wait between loads</em>. Both TMA transfers now in-flight. Consumer still blocked.",
        buf0: {class: "loading", load: "Waiting", store: "Idle"},
        buf1: {class: "loading", load: "Waiting", store: "Idle"}
      },
      {
        step: 3, prod: "Prefetch Done", cons: "consumer_wait(buf0)", phase: "prologue",
        info: "<span class='phase-label phase-prologue'>PROLOGUE → MAINLOOP</span><br><strong>Transition:</strong> All prefetch loads issued. Consumer calls <code>consumer_wait(buf0)</code>, blocking on mbarrier until TMA signals <code>::complete_tx</code>.",
        buf0: {class: "loading", load: "Waiting", store: "Idle"},
        buf1: {class: "loading", load: "Waiting", store: "Idle"}
      },
      {
        step: 4, prod: "producer_acquire(buf0)", cons: "WGMMA on Buffer 0", phase: "mainloop",
        info: "<span class='phase-label phase-mainloop'>MAINLOOP</span><br><strong>First Iteration:</strong> TMA completes → mbarrier auto-signals → <strong>Load Barrier 0 = Signaled</strong>. Consumer unblocks, starts WGMMA. Producer calls <code>producer_acquire(buf0)</code> to check if buffer can be reused.",
        buf0: {class: "computing", load: "Signaled", store: "Waiting"},
        buf1: {class: "ready", load: "Signaled", store: "Idle"}
      },
      {
        step: 5, prod: "Waiting (buf0 in use)", cons: "consumer_release(buf0) → WGMMA Buf1", phase: "mainloop",
        info: "<span class='phase-label phase-mainloop'>MAINLOOP</span><br><strong>Handoff:</strong> Consumer finishes Buffer 0, calls <code>consumer_release(buf0)</code> → <strong>Store Barrier 0 = Signaled</strong>. Consumer immediately starts WGMMA on Buffer 1.",
        buf0: {class: "ready", load: "Signaled", store: "Signaled"},
        buf1: {class: "computing", load: "Signaled", store: "Waiting"}
      },
      {
        step: 6, prod: "cp.async.bulk → Buf0", cons: "WGMMA on Buffer 1", phase: "mainloop",
        info: "<span class='phase-label phase-mainloop'>MAINLOOP — STEADY STATE</span><br><strong>True Overlap:</strong> Producer sees Store Barrier 0 signaled → buffer free. Issues <code>cp.async.bulk</code> to reload Buffer 0 <em>while</em> consumer computes on Buffer 1. Memory latency hidden!",
        buf0: {class: "loading", load: "Waiting", store: "Idle"},
        buf1: {class: "computing", load: "Signaled", store: "Waiting"}
      },
      {
        step: 7, prod: "cp.async.bulk → Buf1", cons: "WGMMA on Buffer 0", phase: "mainloop",
        info: "<span class='phase-label phase-mainloop'>MAINLOOP — STEADY STATE</span><br><strong>Ping-Pong:</strong> Roles swap. Producer reloads Buffer 1 while consumer computes on Buffer 0. Pipeline runs indefinitely with full overlap.",
        buf0: {class: "computing", load: "Signaled", store: "Waiting"},
        buf1: {class: "loading", load: "Waiting", store: "Signaled"}
      }
    ];

    let currentStep = 0;

    function updateDisplay() {
      const s = steps[currentStep];
      document.getElementById('stepNum').textContent = s.step;
      document.getElementById('prodStatus').textContent = s.prod;
      document.getElementById('consStatus').textContent = s.cons;
      document.getElementById('stepInfo').innerHTML = s.info;

      ['buf0', 'buf1'].forEach((bufId, idx) => {
        const buf = document.getElementById(bufId);
        const config = s[bufId];
        buf.className = 'buffer ' + config.class;

        const loadBar = document.getElementById('load' + idx);
        loadBar.textContent = `Load: ${config.load}`;
        loadBar.className = 'barrier ' + config.load.toLowerCase();

        const storeBar = document.getElementById('store' + idx);
        storeBar.textContent = `Store: ${config.store}`;
        storeBar.className = 'barrier ' + config.store.toLowerCase();
      });
    }

    function nextStep() {
      currentStep = (currentStep + 1) % steps.length;
      updateDisplay();
    }

    updateDisplay();
  </script>
</body>

</html>
